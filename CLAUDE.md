# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

QuantSage is a production-ready multi-asset trading system built with an event-driven architecture. The same code runs in backtesting, paper trading, and live trading modes, eliminating backtest-to-live discrepancies. Currently focused on cryptocurrency trading via CCXT (Coinbase), with plans to expand to stocks via Alpaca.

**Current Status**: Week 6-7 (Live Trading & Monitoring) - Core infrastructure, strategies, risk management, backtesting engine, live trading components, and real-time web dashboard are complete. System is ready for paper trading validation.

## Development Commands

### Environment Setup
```bash
# Create and activate virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Configure environment
cp .env.example .env
# Edit .env with API keys (COINBASE_API_KEY, COINBASE_API_SECRET, etc.)
```

### Testing
```bash
# Run all tests
pytest

# Run specific test file
pytest tests/test_strategies.py

# Run with coverage
pytest --cov=src tests/

# Run specific test by name
pytest tests/test_backtest.py::test_backtest_full_cycle -v
```

### Running Backtests
```bash
# Collect historical data first
python scripts/collect_data_for_backtest.py

# Run backtest with mean reversion strategy
python scripts/run_backtest.py --strategy mean_reversion --symbols BTC/USD ETH/USD --start 2024-01-01 --end 2024-12-31

# Backtest results saved to data/backtests/ with HTML reports
```

### Database Operations
```bash
# Initialize database with schema
python scripts/init_db.py

# Database location: data/quantsage.db (SQLite)
# Backtest databases: data/backtests/{backtest_id}.db
```

### Running the Dashboard
```bash
# Start real-time monitoring dashboard
python scripts/run_dashboard.py

# Open browser to http://localhost:8050
# Dashboard shows: portfolio value, positions, trades, equity curve, performance metrics

# Optional: Use custom database or port
python scripts/run_dashboard.py --db data/custom.db --port 9000
```

### Paper Trading
```bash
# Run paper trading demo (simulated market data)
python scripts/paper_trading_demo.py

# Run with dashboard for live monitoring:
# Terminal 1: python scripts/run_dashboard.py
# Terminal 2: python scripts/paper_trading_demo.py
```

## Architecture Overview

### Event-Driven System
The entire system communicates through events via an EventBus. This ensures the same code runs in backtest and live modes.

**Event Flow**:
```
Data Collector → MarketDataEvent → Strategies → SignalEvent →
RiskManager → OrderEvent → ExecutionEngine → FillEvent →
PortfolioManager → PositionUpdateEvent
```

**Key Event Types**:
- `MarketDataEvent`: New price/volume data from exchanges
- `SignalEvent`: Trading signal generated by strategy
- `OrderEvent`: Order request approved by risk manager
- `FillEvent`: Order executed (simulated or real)
- `PositionUpdateEvent`: Position opened/closed/updated
- `RiskAlertEvent`: Risk limit violation

### Core Components

#### 1. Event System (`src/core/`)
- `events.py`: All event class definitions (MarketDataEvent, SignalEvent, etc.)
- `event_bus.py`: Pub/sub event distribution with history tracking for backtests
- `config.py`: Configuration management from YAML files

**Important**: EventBus has two modes:
- `mode='backtest'`: Stores all events in history for analysis
- `mode='live'`: Real-time only, no history storage

#### 2. Data Layer (`src/data/`)
- `collectors/`: Fetch data from exchanges (CCXT for crypto, Alpaca for stocks)
- `validators.py`: Validate data quality (price consistency, outliers, timestamps)
- `storage.py`: DatabaseManager with parameterized queries (secure against SQL injection)
- `features.py`: Technical indicator calculation

**Database**: All queries use parameterized statements (`cursor.execute(query, params)`) to prevent SQL injection. Never use string interpolation for SQL.

#### 3. Strategy Layer (`src/strategies/`)
All strategies inherit from `BaseStrategy` (abstract base class):

```python
class MyStrategy(BaseStrategy):
    def on_market_data(self, event: MarketDataEvent) -> Optional[SignalEvent]:
        # Calculate indicators
        # Check entry/exit conditions
        # Return signal if conditions met
        if conditions_met:
            return self._create_signal(...)
        return None
```

**Existing Strategies**:
- `mean_reversion.py`: Bollinger Bands + RSI + Z-score
- `momentum.py`: EMA crossover (planned)
- `ml_strategy.py`: XGBoost classifier (planned)

**Strategy Lifecycle**:
1. Initialize with config, event_bus, database
2. Subscribe to MarketDataEvent (automatic in BaseStrategy)
3. Process each market data event
4. Generate SignalEvent when conditions met
5. BaseStrategy automatically publishes signals to event bus

#### 4. Risk Management (`src/risk/`)
Multi-layer risk validation (validates ALL signals before execution):

**Layer 1 - Position Level**:
- Max 10% of portfolio per position
- Stop-loss required and must be reasonable (0.5% - 10%)

**Layer 2 - Symbol Level**:
- Max 15% exposure per symbol across all strategies

**Layer 3 - Portfolio Level**:
- Max 80% total invested (20% cash reserve)
- Correlation limits between positions

**Layer 4 - System Level (Circuit Breakers)**:
- Daily loss limit: -5%
- Max drawdown: -20%
- Once triggered, trading halts (sticky until manual reset)

**Flow**: RiskManager subscribes to SignalEvent → validates → publishes OrderEvent (approved) OR RiskAlertEvent (rejected)

#### 5. Backtesting (`src/backtesting/`)
- `engine.py`: Main orchestrator that replays historical data
- `execution.py`: Simulates order fills with slippage and commissions
- `portfolio.py`: Tracks positions, calculates P&L and equity curve
- `metrics.py`: Calculates performance metrics (Sharpe, Sortino, drawdown, etc.)
- `report.py`: Generates HTML reports with Plotly charts

**Backtesting Process**:
1. Load historical data from database
2. Group by timestamp for chronological processing
3. For each timestamp:
   - Publish MarketDataEvents for all symbols
   - Process event queue (strategy → risk → execution → portfolio)
   - Update portfolio value and equity curve
4. Close open positions at end
5. Calculate metrics and generate report

**Slippage Model**: Volume-based (base 0.1% + volume impact)
**Commissions**: Crypto 0.4-0.6% (Coinbase taker fees), Stocks $0 (Alpaca)

#### 6. Portfolio Management (`src/portfolio/`)
- Converts signals to orders with position sizing
- Tracks all open positions
- Calculates realized and unrealized P&L
- Manages stop-loss and take-profit orders
- Publishes PositionUpdateEvents

#### 7. Monitoring & Dashboard (`src/monitoring/`)
- `dashboard.py`: Real-time web dashboard built with Plotly Dash
- Auto-refreshes every 5 seconds
- Displays: Portfolio value, cash balance, open positions, P&L, equity curve
- Shows recent signals, trades, and performance metrics
- Accessible at http://localhost:8050 by default

**Dashboard Features**:
- Portfolio summary cards (value, cash, P&L, positions count)
- Interactive equity curve chart
- Open positions table with real-time P&L
- Recent signals and trades tables
- Performance metrics (win rate, profit factor, etc.)

### Configuration Architecture
All configuration in YAML files (no magic numbers in code):

```
config/
├── config.yaml              # System config (mode, database, symbols)
├── risk.yaml               # Risk limits (all 4 layers)
└── strategies/             # Strategy-specific parameters
    ├── mean_reversion_crypto.yaml
    ├── momentum_crypto.yaml
    └── ml_strategy.yaml
```

Access config: `config.get('system.mode')` or `config.get_enabled_strategies()`

## Database Schema

### Key Tables
- `market_data`: OHLCV data with timestamp index
- `positions`: Open/closed positions with P&L tracking
- `orders`: Order history with fill information
- `trades`: Individual trade executions
- `signals`: Strategy signals generated
- `backtest_results`: Backtest performance metrics
- `risk_events`: Risk violations and alerts

### Important Relationships
- One position can have multiple orders (entry + exit)
- One order can result in multiple trades (partial fills)
- Signals lead to positions (via orders)
- All timestamps stored as ISO format strings

## Code Patterns and Conventions

### Event-Driven Pattern
Components communicate ONLY through events. Never call methods directly across components.

**Good**:
```python
signal = SignalEvent(...)
self.event_bus.publish(signal)  # RiskManager will receive it
```

**Bad**:
```python
order = risk_manager.validate_signal(signal)  # Direct coupling
```

### Strategy Implementation
When adding a new strategy:
1. Inherit from `BaseStrategy`
2. Implement `on_market_data()` method
3. Use `self._create_signal()` to generate signals
4. Use `self.get_recent_data()` to query historical data
5. Configuration in `config/strategies/{strategy_name}.yaml`

### Risk-First Development
Every order MUST pass through RiskManager. Never bypass risk checks. If risk validation fails, signal is rejected and RiskAlertEvent is published.

### Database Access
Always use parameterized queries:
```python
# Good
query = "SELECT * FROM positions WHERE symbol = ? AND status = ?"
results = db.execute_query(query, (symbol, 'OPEN'))

# Bad - SQL injection risk
query = f"SELECT * FROM positions WHERE symbol = '{symbol}'"  # NEVER DO THIS
```

## Testing Strategy

### Test Structure
```
tests/
├── test_strategies.py       # Strategy logic tests
├── test_risk_manager.py     # Risk validation tests
├── test_backtest.py         # End-to-end backtest tests
└── fixtures/                # Sample data for tests
```

### Running Specific Tests
```bash
# Test event flow
pytest tests/ -k "event" -v

# Test risk management
pytest tests/test_risk_manager.py -v

# Test specific strategy
pytest tests/test_strategies.py::test_mean_reversion_signal -v
```

## Common Pitfalls

1. **Don't bypass events**: Never call component methods directly. Always use EventBus.

2. **SQL injection**: Always use parameterized queries. Never use f-strings or string interpolation for SQL.

3. **Backtest mode**: EventBus must be initialized with `mode='backtest'` to store event history. Live mode doesn't store history.

4. **Risk checks**: Never create OrderEvent directly from SignalEvent. Must go through RiskManager.

5. **Position sizing**: Strategies return position size as percentage (0-1), not dollar amount. PortfolioManager converts to quantity.

6. **Timestamp formats**: All timestamps stored as ISO strings in database. Use `.isoformat()` when inserting, parse when reading.

7. **Circuit breakers**: Once triggered, they're sticky. Must be manually reset with `risk_manager.reset_circuit_breaker()`.

## File Organization

```
quantsage/
├── src/
│   ├── core/              # Event system, config
│   ├── data/              # Data collection, storage, features
│   ├── strategies/        # Trading strategies
│   ├── risk/              # Risk management
│   ├── backtesting/       # Backtest engine
│   ├── portfolio/         # Portfolio management
│   ├── execution/         # Order execution
│   ├── monitoring/        # Real-time web dashboard ✅
│   └── ml/                # ML models (future)
├── config/                # YAML configurations
├── scripts/               # Utility scripts
├── tests/                 # Test suite
├── data/                  # Databases and data files
│   ├── quantsage.db       # Main database
│   └── backtests/         # Backtest results
└── docs/                  # Architecture and progress docs
```

## Key Design Principles

1. **Event-Driven**: All communication through events for loose coupling
2. **Same Code, Different Modes**: Backtest, paper, and live use identical code paths
3. **Configuration Over Code**: Parameters in YAML, not hardcoded
4. **Defensive Programming**: Validate everything, fail fast, log detailed errors
5. **Risk-First**: Multi-layer risk validation before every trade
6. **Realistic Simulation**: Accurate slippage and commission modeling in backtests

## Trading Approach

**Current Focus**: Cryptocurrency (Coinbase)
- Backtesting and paper trading only (no real money yet)
- Realistic fee modeling (0.4-0.6% taker fees)
- Event-driven architecture validated in backtest mode

**Future**: Stocks (Alpaca)
- Add after crypto system validated
- Commission-free trading
- Same event-driven architecture

## Additional Resources

- `/docs/ARCHITECTURE.md`: Detailed architecture documentation
- `/docs/PROJECT_PLAN.md`: Development timeline and milestones
- `/docs/PROGRESS.md`: Week-by-week progress tracking
- Database schema: `src/data/schema.sql`
